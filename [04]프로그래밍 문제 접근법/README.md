## 프로그래밍 면접 이렇게 준비한다

### :four: 장 프로그래밍 문제 접근법

<br>

:white_check_mark: 소통이 핵심이다

```
항상 무슨 일을 하고 있는지 설명하자. 그렇게하지 않으면 면접관 입장에서는 지원자가 복잡한 프로그래밍 문제를 공략하는 방법을 
제대로 알고 있는지 전혀 알 수가 없다. ex)여기에서는 배열을 전부 0으로 초기화합니다.
```

:white_check_mark: 기본 단계

```
1. 문제를 확실히 이해한다.
2. 일단 문제를 이해하고 나면 간단한 예를 시도해본다.
3. 문제 풀이에 사용할 알고리즘과 자료구조에 초점을 맞춘다.
4. 알고리즘과 구현 방법을 알아내고 나면 면접관에게 풀이를 설명한다.
5. 코딩을 할 때도 뭘 하고 있는지 설명한다.
6. 필요하다면 질문을 한다. ex) 잘 기억이 안나서 그러는데요, 지역화된 날짜 시간을 출력할 때 어떤 문자열을 쓰는지 알 수 있을까요?
7. 코드를 완성하고 나면 바로 몇 가지 예를 시도해보고 맞는지 확인한다.
8. 모든 오류 및 특수 상황, 특히 경계 조건을 확인한다.
```

:white_check_mark: 문제를 풀다가 막히는 경우

```
1. 예를 다시 따져본다. 그래도 안풀리면 특정 예를 다시 따져본다.
2. 다른 자료구조를 시도해본다.
3. 언어에서 그리 많이 쓰이지 않는 기능 또는 고급 기능을 고려해본다.
```


:white_check_mark: 빅 오 분석

```c++
/* n개의 음이 아닌 정수의 배열에서 가장 큰 값 반환 */
int CompareToMax(int array[], int n){
  int curMax,i;
  
  /* 배열에 적어도 하나 이상의 원소가 있는지 확인 */
  if(n<=0)
    return -1;
   
  /* 지금까지 확인한 값 중 최댓값을 저장할 변수에 배열의 첫 번째 값 저장 */
  curMax=array[0];
  
  /* 모든 수를 최댓값과 비교함 */
  for(i=1;i<n;i++){
    if(array[i]>curMax){{
      curMax=array[i];
    }
  }
  return curMax;
}
```

```c++
/* n개의 음이 아닌 정수의 배열에서 가장 큰 값 반환 */
int CompareToAll(int array[], int n){
  int i,j;
  bool isMax;
  
  /* 배열에 적어도 하나 이상의 원소가 있는지 확인 */
  if(n<=0)
    return -1;
   
   for(i=n-1;i>0;i--){
    isMax=true;
    for(j=0;j<n;j++){
      /* 더 큰 값이 있는지 확인 */
      if(array[j]>array[i]){
        isMax=false; /* array[i]가 최댓값이 아님 */
      }
      /* isMax가 참이면 더 큰 값이 없는 것이므로 array[i]가 최댓값이다 */
     if(isMax)break;
   }
  return array[i];
}
```

```
 CompareToMax 에서는 각 배열 원소와 최댓값을 한 번씩 비교. 따라서 n개의 입력된 항목이 각각 한 번씩 확인되기 때문에 
총 n번의 확인 작업이 수행. 이런 상황을 O(n)이라 표현하며 선형시간 내에 수행된다고 말한다. 
입력된 항목의 개수에 비례하여 선형적으로 증가한다. 
자세하게는 처음에 배열에 하나 이상 원소가 있는지 확인하는 것과 curMax 변수의 값을 초기화하는 부분이 있어 O(n+2) 이다. 
하지만 +2는 무시될 수 있다.
````


:white_check_mark: 최선, 평균, 최악 케이스

```
 CompareToAll 에서 최대 원소가 배열의 맨 뒤에 있다고 가정하면, n개의 원소를 n개의 다른 원소하고 비교해야 하므로 
O(n^2) 이다. 이는 최악이고, 평균을 따져 최댓값이 가운데 있다고  가정하면, 절반만 n번씩 확인하면 되므로, O(n^2/2) 이다.
하지만 1/2은 큰 의미가 없다. 
최선의 경우는 최댓값이 맨 앞에 있는 경우인데, 이때는 최댓값을 다른 모든 값들과 딱 한번씩만 비교하면 되므로 O(n) 이 된다.

최종적으로, CompareToMax의 경우는 최선,최악,평균 케이스 모두가 O(n) 이므로, 배열 안에 값들이 어떤 식으로 들어가 있든 상관없으므로 좋다.
```


:white_check_mark: 빅 오 분석법을 적용하는 방법

```
1. 입력 값이 무엇인지 확인하고 어떤 것을 n으로 놓아야 할지 결정한다.
2. 알고리즘에서 수행해야 할 연산 횟수를 n의 식으로 표현한다.
3. 차수가 제일 높은 항만 남긴다.
4. 모든 상수 인수를 없앤다.
```


:white_check_mark: 어떤 알고리즘이 나을까?
| 종류  | 설명                                                   | 성능 |
| ------- | ------------------------------------------------------ | --------------------- |
| O(log n)| 실행 시간이 입력 크기의 로그에 비례. 로그 알고리즘   | 1                  |
| O(n)    | 실행 시간에 입력 크기에 바로 비례. 선형 알고리즘              | 2                  |
| O(n log n)    | 준선형 알고리즘. 속도가 선형 알고리즘과 다항식 알고리즘의 중간 정도                     | 3                  |
| O(n^c)     | 입력 크기가 늘어나면 실행 시간이 빠르게 늘어남. 다항식 알고리즘                   | 4                  |
| O(c^n)   | 다항식 알고리즘보다도 실행 시간이 빠르게 늘어남. 지수 알고리즘 | 5                  |
| O(n!) | n이 작아도 금방 거의 쓰기 힘듦. 팩토리얼 알고리즘         | 6                  |




