## 프로그래밍 면접 이렇게 준비한다

### :one::one: 장 객체지향 프로그래밍

<br>

:white_check_mark: 클래스와 객체

객체지향에 대한 정의는 다양하다. 클래스와 객체가 그 중심에 있음은 분명하다. 
- 객체는 다른 객체 인스턴스와는 다른 별도의 상태를 가지고 있는 어떤 클래스의 특정 인스턴스를 뜻한다.
- 클래스는 속성(성질이나 상타)과 행동(능력 또는 메서드)을 가진 무언가를 추상적으로 정의한 것이다.

:white_check_mark: 생성과 파괴

객체는 클래스의 인스턴스다.
- 객체를 만드는 것을 객체를 생성한다고 부른다. 클래스에 있는 생성자 메서드를 호출한다. 생성자에서는 객체의 상태를 초기화하며, 그 과정에서 직접적으로든 간접적으로든 부모로부터 상속 받은 상태 부분을 초기화할 수 있도록 부모 클래스의 생성자를 호출하는 작업이 이루어짐.
- 파괴자라는 메서드를 호출하여 객체의 상태를 모두 제거(C++)

:white_check_mark: 상속과 다형성
- 상속은 어떤 클래스에서 더 특화된 버전의 클래스를 위한 행동을 제공할 수 있게 해준다.
- 오버라이딩과 관련된 OOP의 핵심 개념으로 객체의 클래스를 바탕으로 실행 시에 사용할 메서드의 정의를 선택하는 기능이 '다형성'이다.

:white_check_mark: 인터페이스와 추상 클래스
```
객체지향 프로그래밍에서 인터페이스와 추상 클래스 사이의 차이점을 설명하라.
```
- 인터페이스에서는 클래스와 별도로 일련의 연관된 메서드를 선언한다.
- 추상 클래스는 메서드를 선언하기는 하지만 모든 메서드를 정의하지 않는 불완전하게 정의된 클래스이다.

어떤 클래스에서 직접적으로든 간접적으로든 특정 인터페이스에서 정한 모든 메서드를 정의한다면 그 클래스는 해당 인터페이스를 구현한다고 표현한다.
인터페이스와 달리 추상 클래스는 그 자체가 클래스다. 데이터 멤버도 들어갈 수 있고 다른 클래스의 서브클래스로 만들 수도 있다.
하지만 (추상이 아닌) 구상 클래스와 달리 행동 중 일부는 정의하지 않고 서브클래스에서 정의해서 쓰도록 남겨둔다. 
이런 이유 때문에 추상 클래스의 인스턴스는 만들 수 없다.
일반적으로 추상 클래스는 그것을 베이스 클래스로 상속해서 더 구체적인 클래스를 만들어서 쓰는 경우에 쓰기 좋다.
특히 서브클래스에서 써먹을 수 있는 공통적인 기능을 추상 베이스 클래스에 집어넣을 필요가 있을 때 좋다.
서로 관련이 없는 클래스에서 개념적으로 연관된 기능을 작동시킬 수 있는 공통된 방식이 필요하나, 구현하는 방법이 다른 경우에는 인터페이스가 좋다.
- 인터페이스 : 공통된 방식, 다른 구현
- 추상 클래스 : 공통적인 기능

:white_check_mark: 가상 메서드
```
가상 메서드가 무엇인지 기술하고 어떻게 활용할 수 있는지 설명하라.
```
- 가상 메서드는 실행 시에 그 메서드가 실제로 호출되는 객체가 어떤 유형(클래스)인지에 따라 호출할 메서드 정의가 결정되는 메서드를 뜻한다.
- 비가상 메서드는 컴파일 시에 쓰이는 클래스형에 따라 어떤 메서드가 호출되는지 결정된다.
- 가상 메서드는 다형성을 활용할 때 유용하다. 같은 메서드를 호출해도 객체의 클래스에 따라 다르게 정의된 메서드가 작동하기 때문이다.
- 단점으로는 호출할 때 시간이 더 오래 걸린다. 메서드를 선택하기 위한 룩업이 꼭 필요하기 때문이다. 이 정보를 저장하기 위한 별도의 메모리도 필요하다. 하지만 이 오버헤드는 거의 무시될 정도다.

:white_check_mark: 다중 상속
```
C#과 자바에서 클래스의 다중 상속을 허용하지 않는 이유는?
```
- 한 클래스가 두 개의 서로 다른 클래스를 상속하는데, 그 두 부모 클래스가 한 클래스로부터 파상된 클래스인 경우 애매모호해진다.
```java
class A{
protected:
  bool flag;
};
class B : public A{};
class C : public A{};
class D : public B, public C{
public:
  void setFlag(bool nflag){
    flag=nflag; //애매하다.
  }
};
```
B와 C는 둘 다 A의 서브클래스이므로, D의 클래스 계층구조를 보면 A가 두번 등장하게 되어 flag가 두 개 만들어지는 셈이 된다. 즉, 어떤 것을 써야 할지 모르는 상황 발생.
따라서 컴파일러는 D에서 flag에 대한 레퍼런스가 모호하다는 메시지 내보냄.
- 해결책으로는 B::flag=nflag; 와 같이 레퍼런스를 명시적으로 표시하는 방법이 있다. 또한, B와 C를 가상 베이스 클래스로 선언하여 클래스 계층구조에 A의 사본이 하나만 들어가도록 하는 방법이 있다. 

:white_check_mark: 자원 관리
```
제한된 시스템 자원에 접근해야 하는 함수가 있다고 해보자. 이 코드에서는 openResource라는 API 함수를 호출하여 그 자원에 대한 핸들을 가져와야 하고,
일이 끝나면 closeResource라는 함수에 이 핸들을 넘겨줘야 한다. 어떤 경우라도 closeResource 함수를 반드시 호출해서 자원을 잃어버리지 않으려면
어떻게 해야할까?
```
- 함수 맨 뒤에 리턴하기 직전에 closeResource를 호출
```
함수에 return 선언문이 두개 이상이라면, return 선언문 앞에 일일이 closeResource 호출해야함. 이는 유지보수가 어렵고 에러도 쉽게 발생함.
```
- 자바의 경우, try - finally 블록을 제공하고 finally 블록안에 closeResource 호출.
```java
public static void useResource(){
  ResourceHandle r = openResource(); // try 안에 있으면, 만약 자원을 제대로 못받아오면 널 레퍼런스에 대해 close함수가 호출.
  //이는 오류 및 예측불가 행동 유발
  try{
    //자원을 이용하여 필요 작업 처리
  }
  finally{
    closeResource(r);
  }
}
```







